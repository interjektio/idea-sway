// NOTE: this is generated by ChatGPT -- handle with care
package fi.interjektio.dev.idea.sway.lang.lexer

import com.intellij.lexer.LexerBase
import com.intellij.psi.tree.IElementType
import fi.interjektio.dev.idea.sway.lang.psi.SwayTypes
import com.intellij.psi.TokenType

class SwayLexer : LexerBase() {
    private var buffer: CharSequence = ""
    private var startOffset: Int = 0
    private var endOffset: Int = 0
    private var state: Int = 0
    private var currentToken: IElementType? = null

    // Extracted patterns from `sway.tmLanguage.json`
    private val keywords = setOf(
        "fn", "let", "mut", "struct", "enum", "impl", "trait", "pub",
        "mod", "const", "return", "true", "false", "if", "else", "for", "while",
        "break", "continue", "match", "use", "where", "self", "as", "in",
        "abi", "contract", "storage", "dep"
    )

    private val types = setOf(
        "u8", "u16", "u32", "u64", "bool", "b256", "str", "Self"
    )

    private val operators = setOf(
        "+", "-", "*", "/", "%", "&&", "||", "!", "==", "!=", "<=", ">=", "<", ">", "=>", "="
    )

    private val numberPattern = Regex("\\b\\d+(_\\d+)*\\b")
    private val identifierPattern = Regex("\\b[a-zA-Z_][a-zA-Z0-9_]*\\b")
    private val stringPattern = Regex("\"(?:\\\\.|[^\"])*\"")
    private val commentPattern = Regex("//.*|/\\*[\\s\\S]*?\\*/")
    private val operatorPattern = Regex(operators.joinToString("|") { Regex.escape(it) })

    override fun start(buffer: CharSequence, startOffset: Int, endOffset: Int, initialState: Int) {
        this.buffer = buffer
        this.startOffset = startOffset
        this.endOffset = startOffset
        this.state = initialState
        advance()
    }

    override fun getState(): Int = state

    override fun getTokenType(): IElementType? = currentToken

    override fun getTokenStart(): Int = startOffset

    override fun getTokenEnd(): Int = endOffset

    override fun advance() {
        if (endOffset >= buffer.length) {
            currentToken = null
            return
        }

        startOffset = endOffset
        val text = buffer.subSequence(startOffset, buffer.length).toString()

        when {
            text[0].isWhitespace() -> {
                while (endOffset < buffer.length && buffer[endOffset].isWhitespace()) {
                    endOffset++
                }
                currentToken = TokenType.WHITE_SPACE
            }

            commentPattern.find(text)?.range?.first == 0 -> {
                endOffset += commentPattern.find(text)?.value?.length ?: 1
                currentToken = SwayTypes.COMMENT
            }

            stringPattern.find(text)?.range?.first == 0 -> {
                endOffset += stringPattern.find(text)?.value?.length ?: 1
                currentToken = SwayTypes.STRING
            }

            numberPattern.find(text)?.range?.first == 0 -> {
                endOffset += numberPattern.find(text)?.value?.length ?: 1
                currentToken = SwayTypes.NUMBER
            }

            identifierPattern.find(text)?.range?.first == 0 -> {
                val word = identifierPattern.find(text)?.value ?: ""
                endOffset += word.length

                currentToken = when {
                    word in keywords -> SwayTypes.KEYWORD
                    word in types -> SwayTypes.TYPE
                    else -> SwayTypes.IDENTIFIER
                }
            }

            operatorPattern.find(text)?.range?.first == 0 -> {
                endOffset += operatorPattern.find(text)?.value?.length ?: 1
                currentToken = SwayTypes.OPERATOR
            }

            else -> {
                endOffset++
                currentToken = TokenType.BAD_CHARACTER
            }
        }
    }

    override fun getBufferSequence(): CharSequence = buffer

    override fun getBufferEnd(): Int = buffer.length
}